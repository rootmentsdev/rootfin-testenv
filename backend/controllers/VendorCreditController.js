// Updated to use PostgreSQL (Sequelize) instead of MongoDB
import { VendorCredit, sequelize } from "../models/sequelize/index.js";
import { Op } from 'sequelize';

// Create a new vendor credit
export const createVendorCredit = async (req, res) => {
  try {
    const creditData = req.body;
    
    // Validate required fields
    if (!creditData.creditNoteNumber || !creditData.vendorName || !creditData.userId) {
      return res.status(400).json({ message: "Credit note number, vendor name, and userId are required" });
    }
    
    // vendorId is now a UUID string from PostgreSQL Vendor (optional field)
    if (!creditData.vendorId) {
      creditData.vendorId = null;
    }
    
    // Ensure items is an array
    if (creditData.items && !Array.isArray(creditData.items)) {
      creditData.items = [];
    }
    
    // Ensure discount is an object
    if (creditData.discount && typeof creditData.discount !== 'object') {
      creditData.discount = { value: '0', type: '%' };
    }
    
    // UUID will be auto-generated by the model if not provided
    // Make creditNoteNumber unique per user (email) instead of globally unique
    const existingCredit = await VendorCredit.findOne({ 
      where: {
        creditNoteNumber: creditData.creditNoteNumber,
        userId: creditData.userId
      }
    });
    
    if (existingCredit) {
      return res.status(409).json({ message: "Credit note number already exists for this user" });
    }
    
    const vendorCredit = await VendorCredit.create(creditData);
    res.status(201).json(vendorCredit.toJSON());
  } catch (error) {
    console.error("Create vendor credit error:", error);
    console.error("Error details:", {
      name: error.name,
      message: error.message,
      errors: error.errors
    });
    
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({ message: "Credit note number already exists" });
    }
    
    // Handle validation errors
    if (error.name === "SequelizeValidationError") {
      const errors = error.errors.map(e => e.message).join(", ");
      return res.status(400).json({ message: "Validation error", error: errors });
    }
    
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Get all vendor credits for a user
export const getVendorCredits = async (req, res) => {
  try {
    const { userId, userPower, status } = req.query;
    const whereClause = {};
    
    const isAdmin = userPower && (userPower.toLowerCase() === 'admin' || userPower.toLowerCase() === 'super_admin');
    
    if (!isAdmin && userId) {
      whereClause.userId = userId;
    }
    // If admin, no userId filter - show all credits
    
    if (status) whereClause.status = status;
    
    const vendorCredits = await VendorCredit.findAll({
      where: whereClause,
      order: [['createdAt', 'DESC']],
    });
    res.status(200).json(vendorCredits.map(credit => credit.toJSON()));
  } catch (error) {
    console.error("Get vendor credits error:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Get a single vendor credit by ID
export const getVendorCreditById = async (req, res) => {
  try {
    const { id } = req.params;
    const vendorCredit = await VendorCredit.findByPk(id);
    
    if (!vendorCredit) {
      return res.status(404).json({ message: "Vendor credit not found" });
    }
    res.status(200).json(vendorCredit.toJSON());
  } catch (error) {
    console.error("Get vendor credit error:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Update a vendor credit
export const updateVendorCredit = async (req, res) => {
  try {
    const { id } = req.params;
    const creditData = req.body;
    
    // Ensure items is an array
    if (creditData.items && !Array.isArray(creditData.items)) {
      creditData.items = [];
    }
    
    // Ensure discount is an object
    if (creditData.discount && typeof creditData.discount !== 'object') {
      creditData.discount = { value: '0', type: '%' };
    }
    
    // Check if creditNoteNumber is being changed and if it already exists
    if (creditData.creditNoteNumber) {
      const existingCredit = await VendorCredit.findOne({ 
        where: {
          creditNoteNumber: creditData.creditNoteNumber,
          userId: creditData.userId || req.body.userId,
          id: { [Op.ne]: id } // Exclude current credit
        }
      });
      
      if (existingCredit) {
        return res.status(409).json({ 
          message: "Credit note number already exists",
          existingCredit: existingCredit.toJSON()
        });
      }
    }
    
    // Update the credit
    const [updatedRows] = await VendorCredit.update(creditData, {
      where: { id },
      returning: true,
    });
    
    if (updatedRows === 0) {
      return res.status(404).json({ message: "Vendor credit not found" });
    }
    
    const vendorCredit = await VendorCredit.findByPk(id);
    console.log(`Vendor credit ${vendorCredit.creditNoteNumber} updated in PostgreSQL with ID: ${vendorCredit.id}`);
    res.status(200).json(vendorCredit.toJSON());
  } catch (error) {
    console.error("Update vendor credit error:", error);
    if (error.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({ message: "Credit note number already exists" });
    }
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

// Delete a vendor credit
export const deleteVendorCredit = async (req, res) => {
  try {
    const { id } = req.params;
    const deletedRows = await VendorCredit.destroy({
      where: { id },
    });
    
    if (deletedRows === 0) {
      return res.status(404).json({ message: "Vendor credit not found" });
    }
    res.status(200).json({ message: "Vendor credit deleted successfully" });
  } catch (error) {
    console.error("Delete vendor credit error:", error);
    res.status(500).json({ message: "Server error", error: error.message });
  }
};

